from fastapi import FastAPI
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

# создан экземпляр класса
app = FastAPI(
    title='py_hub_api',
    description='Platform',
    version='1.0.0'
)
# запуск серввера python -m uvicorn main:app --reload --host 0.0.0.0 --port 8000
# http://localhost:8000/docs
# http://127.0.0.1:8000/docs

# Модели данных в pydentic
class UserBase(BaseModel):
    username: str
    email: str


class UserCrate(UserBase):
    password: str


class UserResponse(UserBase):
    id: int
    created_at: datetime

    class Config:
        orm_mode: True


class CourseBase(BaseModel):
    title: str
    description: str
    price: float = 0.0


class CourseResponse(CourseBase):
    id: int
    created_at: datetime


# Временное хранилище
users_db = []
courses_db = []


# endpoints
@app.get("/")
async def root():
    return {
        'message': 'Hello',
        'version': '1.0.0',
        'docs': '/docs'
    }


@app.get("/health")
async def health_check():
    return {
        'status': 'healthy',
        'timestamp': datetime.now()
    }


@app.post("/users/", response_model=UserResponse)
async def created_user(user: UserCrate):
    user_date = user.dict()
    user_date["id"] = len(users_db) + 1
    user_date["created_at"] = datetime.now()
    users_db.append(user_date)
    return user_date

@app.get("/users/{id}/", response_model=UserResponse)
async def get_user(user_id: int):
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        return {"error": "User not found"}
    return user


@app.post("/courses/", response_model=CourseResponse)
async def created_courses(course: CourseBase):
    course_date = course.dict()
    course_date["id"] = len(courses_db) + 1
    course_date["created_at"] = datetime.now()
    courses_db.append(course_date)
    return course_date


@app.get("/courses/", response_model=list[CourseResponse])
async def get_courses():
    return courses_db







Отличный вопрос! Давайте разберем логику работы Swagger (OpenAPI) в вашем FastAPI приложении по шагам.


## Как FastAPI интегрируется со Swagger

### 1. Автоматическая генерация документации

```python
app = FastAPI(
    title='py_hub_api',
    description='Platform',
    version='1.0.0'
)
```
- FastAPI автоматически создает OpenAPI спецификацию на основе вашего кода
- При запуске сервера доступны:
  - `http://localhost:8000/docs` - Swagger UI (интерактивная документация)
  - `http://localhost:8000/redoc` - альтернативная документация
  - `http://localhost:8000/openapi.json` - сырая OpenAPI спецификация

### 2. Роль Pydantic моделей в документации

```python
class UserCreate(UserBase):
    password: str

class UserResponse(UserBase):
    id: int
    created_at: datetime
```

Логика работы:
- FastAPI анализирует Pydantic модели для генерации схемы запросов/ответов
- Для каждого endpoint'а определяется:
  - Request Body (тело запроса) - на основе моделей в параметрах
  - Response Model (модель ответа) - через параметр `response_model`

### 3. Механизм работы response_model

```python
@app.post("/users/", response_model=UserResponse)
async def created_user(user: UserCreate):
    user_data = user.dict()
    user_data["id"] = len(users_db) + 1
    user_data["created_at"] = datetime.now()
    users_db.append(user_data)
    return user_data
```

Что происходит:
1. Входные данные валидируются по модели `UserCreate`
2. Выходные данные фильтруются по модели `UserResponse`
3. Swagger показывает только поля из `UserResponse` в документации

### 4. Детальный разбор логики endpoint'ов

#### GET /users/{id}/
```python
@app.get("/users/{user_id}/", response_model=UserResponse)
async def get_user(user_id: int):
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        return {"error": "User not found"}
    return user
```

В Swagger это отображается как:
- Path Parameter: `user_id` (integer, required)
- Response: Schema based on `UserResponse`
- Возможные ответы: 200 OK, 422 Validation Error

#### POST /courses/
```python
@app.post("/courses/", response_model=CourseResponse)
async def created_courses(course: CourseBase):
    course_data = course.dict()
    course_data["id"] = len(courses_db) + 1
    course_data["created_at"] = datetime.now()
    courses_db.append(course_data)
    return course_data
```

В Swagger:
- Request Body: JSON объект с полями из `CourseBase`
- Response: Объект с дополнительными полями `id` и `created_at`

### 5. Как Swagger использует типы данных

```python
from typing import Optional
from datetime import datetime

class CourseBase(BaseModel):
    title: str                    # → string (required)
    description: str             # → string (required)
    price: float = 0.0           # → number (optional, default: 0.0)
```

Преобразование типов:
- `str` → "string" в Swagger
- `int` → "integer"
- `float` → "number"
- `datetime` → "string" format: "date-time"
- `Optional[str]` → поле помечается как необязательное

### 6. Особые случаи и логика

#### Наследование моделей:
```python
class UserBase(BaseModel):
    username: str
    email: str

class UserCreate(UserBase):      # Наследует username, email
    password: str               # + добавляет password

class UserResponse(UserBase):   # Наследует username, email
    id: int                    # + добавляет id, created_at
    created_at: datetime
```

#### ORM Mode:
```python
class Config:
    orm_mode: True
```
- Позволяет модели работать с ORM объектами (SQLAlchemy и т.д.)
- FastAPI будет автоматически извлекать данные из атрибутов объекта

### 7. Полный цикл работы Swagger

1. Пользователь открывает `/docs`
2. Браузер загружает Swagger UI + получает OpenAPI спецификацию
3. Для каждого endpoint'а отображается:
   - HTTP метод и путь
   - Параметры (path, query, body)
   - Модели запроса и ответа
   - Кнопка "Try it out" для тестирования

4. При тестировании через Swagger UI:
   - Генерируется соответствующий HTTP запрос
   - Отображается полный ответ сервера
   - Показываются коды ответов и ошибки


////

////

////


# Полное и подробное объяснение логики работы Swagger в FastAPI

## 1. Основной механизм генерации документации

### Автоматическая OpenAPI спецификация
```python
app = FastAPI(
    title='py_hub_api',
    description='Platform',
    version='1.0.0'
)
```
Что происходит:
- При импорте FastAPI регистрирует все декораторы `@app.get`, `@app.post` и т.д.
- Для каждого endpoint'а анализируются:
  - HTTP метод и путь
  - Параметры функции
  - Pydantic модели
  - Типы возвращаемых значений
- Генерируется JSON спецификация OpenAPI стандарта
- По адресу `/docs` отдается Swagger UI, который читает эту спецификацию

Доступные URL:
- `http://localhost:8000/docs` - интерактивная документация
- `http://localhost:8000/redoc` - альтернативный интерфейс
- `http://localhost:8000/openapi.json` - сырая спецификация

## 2. Детальная работа Pydantic моделей

### Иерархия наследования:
```python
# Базовый класс - общие поля
class UserBase(BaseModel):
    username: str    # → required string в Swagger
    email: str      # → required string

# Для создания - добавляем пароль
class UserCreate(UserBase):
    password: str   # → required string

# Для ответа - добавляем системные поля
class UserResponse(UserBase):
    id: int                    # → required integer
    created_at: datetime       # → string format: date-time

    class Config:
        orm_mode: True        # ← Важно для работы с БД
```

### Логика преобразования типов:
| Python тип | Swagger тип | Особенности |
|------------|-------------|-------------|
| `str` | `string` | Обязательное поле |
| `int` | `integer` | Целое число |
| `float` | `number` | С плавающей точкой |
| `bool` | `boolean` | true/false |
| `datetime` | `string` | format: "date-time" |
| `Optional[str]` | `string` | required: false |
| `List[User]` | `array` | of User objects |

## 3. Полный цикл работы endpoint'ов

### POST /users/ - создание пользователя
```python
@app.post("/users/", response_model=UserResponse)
async def created_user(user: UserCreate):
    # 1. ВАЛИДАЦИЯ ВХОДА: FastAPI проверяет, что в теле запроса:
    #    - username (string, required)
    #    - email (string, required)
    #    - password (string, required)

    user_data = user.dict()  # Преобразуем в dict

    # 2. БИЗНЕС-ЛОГИКА: добавляем системные поля
    user_data["id"] = len(users_db) + 1
    user_data["created_at"] = datetime.now()

    # 3. СОХРАНЕНИЕ: добавляем в "базу данных"
    users_db.append(user_data)

    # 4. ВАЛИДАЦИЯ ВЫХОДА: FastAPI фильтрует ответ по UserResponse
    #    Исключается поле password, остаются только:
    #    - username, email, id, created_at
    return user_data
```

В Swagger UI это отображается как:
- Request Body Schema: UserCreate (с полем password)
- Response Schema: UserResponse (без поля password)
- Пример автоматически сгенерированного запроса:
```json
{
  "username": "string",
  "email": "string",
  "password": "string"
}
```

### GET /users/{user_id}/ - получение пользователя
```python
@app.get("/users/{user_id}/", response_model=UserResponse)
async def get_user(user_id: int):  # ← Path parameter
    # 1. ВАЛИДАЦИЯ ПАРАМЕТРА: user_id должен быть integer
    #    Если строка - автоматическая ошибка 422

    # 2. ПОИСК В БАЗЕ: ищем пользователя по ID
    user = next((u for u in users_db if u["id"] == user_id), None)

    # 3. ОБРАБОТКА НЕНАЙДЕННОГО ПОЛЬЗОВАТЕЛЯ
    if not user:
        return {"error": "User not found"}  # ← НЕ пройдет валидацию UserResponse!

    # 4. ВОЗВРАТ РЕЗУЛЬТАТА: проходит валидацию UserResponse
    return user
```

Проблема: При ненайденном пользователе возвращается объект, не соответствующий UserResponse. В реальном приложении нужно использовать HTTPException.

## 4. Расширенная система валидации

### Автоматическая валидация параметров:
```python
# Path параметры
@app.get("/users/{user_id}")
async def get_user(user_id: int):  # ← автоматическая валидация типа
    pass

# Query параметры
@app.get("/courses/")
async def get_courses(
    skip: int = 0,           # → ?skip=0
    limit: int = 10,         # → ?limit=10
    search: Optional[str] = None  # → ?search=python
):
    pass
```

### Расширенная валидация полей:
```python
from pydantic import Field, EmailStr, validator

class UserCreate(UserBase):
    password: str = Field(
        ...,
        min_length=8,
        description="Password must be at least 8 characters"
    )
    email: EmailStr  # ← автоматическая валидация формата email

    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('Must be alphanumeric')
        return v
```

В Swagger отображается:
- Минимальная длина пароля
- Специальный формат для email
- Описания полей

## 5. Система обработки ошибок

### Автоматические ошибки:
- 422 Unprocessable Entity - невалидные входные данные
- 500 Internal Server Error - необработанное исключение в коде

### Кастомные ошибки:
```python
from fastapi import HTTPException, status

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = next((u for u in users_db if u["id"] == user_id), None)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
            headers={"X-Error": "User missing"}
        )
    return user
```

### Документирование возможных ответов:
```python
@app.get("/users/{user_id}/",
         response_model=UserResponse,
         responses={
             404: {"model": ErrorMessage, "description": "User not found"},
             422: {"description": "Validation Error"},
             500: {"description": "Internal Server Error"}
         })
async def get_user(user_id: int):
    # ...
```

## 6. Dependency Injection System

### Система зависимостей:
```python
from fastapi import Depends

async def get_current_user(token: str = Header(...)):
    # Логика аутентификации
    return user

async def get_db_session():
    # Подключение к БД
    return session

@app.get("/users/me")
async def read_users_me(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db_session)
):
    return current_user
```

Swagger автоматически:
- Добавляет заголовки для аутентификации
- Документирует security schemes
- Показывает обязательные заголовки

## 7. Фоновые задачи и сложная логика

```python
from fastapi import BackgroundTasks

def send_welcome_email(email: str):
    # Имитация отправки email
    print(f"Sending welcome email to {email}")

@app.post("/users/", response_model=UserResponse)
async def create_user(
    user: UserCreate,
    background_tasks: BackgroundTasks
):
    user_data = user.dict()
    user_data["id"] = len(users_db) + 1
    user_data["created_at"] = datetime.now()
    users_db.append(user_data)

    # Фоновая задача - выполняется после отправки ответа
    background_tasks.add_task(send_welcome_email, user.email)

    return user_data
```

## 8. Middleware и глобальная логика

```python
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["*"]
)
```

## 9. Кастомизация документации

```python
app = FastAPI(
    title="PyHub API",
    description="Educational Platform API",
    version="1.0.0",
    openapi_url="/api/v1/openapi.json",
    docs_url="/api/docs",
    redoc_url="/api/redoc",

    # Дополнительные метаданные
    contact={
        "name": "Support Team",
        "email": "support@pyhub.com",
    },
    license_info={
        "name": "MIT",
        "url": "https://opensource.org/licenses/MIT",
    }
)

# Группировка endpoint'ов по тегам
@app.post("/users/", response_model=UserResponse, tags=["Users"])
@app.get("/courses/", response_model=list[CourseResponse], tags=["Courses"])
@app.get("/health", tags=["System"])
```

## 10. Полный цикл запроса-ответа

### Последовательность обработки POST /users/:

1. Получение запроса: FastAPI получает HTTP POST запрос
2. Парсинг JSON: Тело запроса парсится в JSON
3. Валидация входных данных:
   - Проверяется соответствие модели UserCreate
   - Если ошибка - возвращается 422 с деталями
4. Вызов функции: Выполняется код функции created_user
5. Валидация выходных данных:
   - Проверяется соответствие модели UserResponse
   - Поле password исключается из ответа
6. Сериализация: Данные преобразуются в JSON
7. Отправка ответа: Клиент получает ответ

### Что видит пользователь в Swagger:

Before Execute:
```json
// Request Schema
{
  "username": "string",
  "email": "string",
  "password": "string"  // ← видно в запросе
}
```

After Execute:
```json
// Response Schema
{
  "username": "string",
  "email": "string",
  "id": 0,
  "created_at": "2024-01-15T10:30:00.000Z"
  // password отсутствует в ответе
}
```